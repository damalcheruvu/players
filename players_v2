import random
from itertools import combinations
from collections import defaultdict

# List of players (plain text, one player per line, no commas or quotes)
PLAYERS_TEXT = """

Appa
Jeevan
Koti
Madhu
Murali
Phani
Prasad
Praveen
Raghu R
Rambabu
Rao Seema
Ravi G
Tarun
Sreeni
Subhani
Tripura
Srinivas
Vijay
Randeep

"""

# Configuration
CONFIG = {
    "max_courts": 4,  # Maximum number of courts
    "max_rounds": 10,  # Maximum number of rounds
    "print_stats": True,  # Whether to print detailed stats
    "weights": {  # Weights for scoring criteria
        "PARTNERSHIP": 1000,
        "OPPOSITION": 500,
        "GAME_BALANCE": 200,
        "NEW_INTERACTION": 100
    },
    "random_seed": 42  # Random seed for reproducibility (None for randomness)
}

class BadmintonManager:
    def __init__(self, max_courts=4, max_rounds=10, print_stats=False, weights=None, random_seed=None):
        self.max_courts = max_courts
        self.max_rounds = max_rounds
        self.print_stats = print_stats
        self.players = set()
        self.partner_history = defaultdict(lambda: defaultdict(int))
        self.opponent_history = defaultdict(lambda: defaultdict(int))
        self.court_history = defaultdict(lambda: defaultdict(int))
        self.rest_history = defaultdict(int)
        self.games_played = defaultdict(int)
        self.weights = weights or {
            'PARTNERSHIP': 1000,
            'OPPOSITION': 500,
            'GAME_BALANCE': 200,
            'NEW_INTERACTION': 100
        }
        if random_seed is not None:
            random.seed(random_seed)

    def load_players(self, players_text):
        # Split the multiline string into lines, strip whitespace, and remove empty lines
        self.players = set(player.strip() for player in players_text.strip().split("\n") if player.strip())
        if len(self.players) < 4:
            raise Exception("Need at least 4 players to create games")

    def update_history(self, team1, team2, court):
        for p1, p2 in combinations(team1, 2):
            self.partner_history[p1][p2] += 1
            self.partner_history[p2][p1] += 1
        for p1, p2 in combinations(team2, 2):
            self.partner_history[p1][p2] += 1
            self.partner_history[p2][p1] += 1
        for p1 in team1:
            for p2 in team2:
                self.opponent_history[p1][p2] += 1
                self.opponent_history[p2][p1] += 1
        for player in team1 | team2:
            self.court_history[player][court] += 1
            self.games_played[player] += 1

    def calculate_team_score(self, team1, team2):
        score = 0
        for t1p1, t1p2 in combinations(team1, 2):
            score -= self.weights['PARTNERSHIP'] * self.partner_history[t1p1][t1p2]
        for t2p1, t2p2 in combinations(team2, 2):
            score -= self.weights['PARTNERSHIP'] * self.partner_history[t2p1][t2p2]
        for p1 in team1:
            for p2 in team2:
                score -= self.weights['OPPOSITION'] * self.opponent_history[p1][p2]
        team1_games = sum(self.games_played[p] for p in team1)
        team2_games = sum(self.games_played[p] for p in team2)
        score -= self.weights['GAME_BALANCE'] * abs(team1_games - team2_games)
        for p1 in team1:
            for p2 in team2:
                if self.opponent_history[p1][p2] == 0:
                    score += self.weights['NEW_INTERACTION']
        return score

    def generate_round(self, round_num):
        available_players = list(self.players)
        num_players_needed = self.max_courts * 4
        
        if len(available_players) < num_players_needed:
            num_courts = len(available_players) // 4
        else:
            num_courts = self.max_courts

        num_players_needed = num_courts * 4
        resting_players = set()

        if len(available_players) > num_players_needed:
            players_by_rest = sorted(available_players, key=lambda p: (self.rest_history[p], random.random()))
            num_to_rest = len(available_players) - num_players_needed
            resting_players = set(players_by_rest[:num_to_rest])
            for player in resting_players:
                self.rest_history[player] += 1
            available_players = [p for p in available_players if p not in resting_players]

        players_per_court = len(available_players) // num_courts
        best_assignments = []

        for court in range(num_courts):
            court_players = random.sample(available_players, players_per_court)
            team1 = set(court_players[:players_per_court // 2])
            team2 = set(court_players[players_per_court // 2:])
            score = self.calculate_team_score(team1, team2)
            best_assignments.append((court + 1, team1, team2))
            self.update_history(team1, team2, court + 1)
            available_players = [p for p in available_players if p not in court_players]

        return resting_players, best_assignments

    def print_schedule(self):
        for round_num in range(1, self.max_rounds + 1):
            resting_players, court_assignments = self.generate_round(round_num)
            
            # Underlined "Resting Players" heading
            print(f"Round {round_num}")
            print("R̲e̲s̲t̲i̲n̲g̲ ̲P̲l̲a̲y̲e̲r̲s̲: ", end="")
            print(f"{', '.join(sorted(resting_players))}")
            
            for court, team1, team2 in court_assignments:
                print(f"Court {court}: {', '.join(sorted(team1))} vs {', '.join(sorted(team2))}")
            print("-" * 50)

        if self.print_stats:
            self.print_player_stats()

    def print_player_stats(self):
        print("\nPlayer Stats:")
        print("=" * 50)
        for player in sorted(self.players):
            total_games = self.games_played[player]
            total_rests = self.rest_history[player]
            unique_partners = len(self.partner_history[player])
            unique_opponents = len(self.opponent_history[player])
            court_distribution = ", ".join(f"Court {c}: {count}" for c, count in sorted(self.court_history[player].items()))
            print(f"Player: {player}")
            print(f"  Total Games Played: {total_games}")
            print(f"  Total Rested Rounds: {total_rests}")
            print(f"  Unique Partners: {unique_partners}")
            print(f"  Unique Opponents: {unique_opponents}")
            print(f"  Court Distribution: {court_distribution}")
            print("-" * 50)

def main():
    try:
        manager = BadmintonManager(
            max_courts=CONFIG["max_courts"],
            max_rounds=CONFIG["max_rounds"],
            print_stats=CONFIG["print_stats"],
            weights=CONFIG["weights"],
            random_seed=CONFIG["random_seed"]
        )
        manager.load_players(PLAYERS_TEXT)
        manager.print_schedule()
    except Exception as e:
        print(f"Error: {str(e)}")

if __name__ == "__main__":
    main()
